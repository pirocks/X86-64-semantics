// Autogenerated using stratification.
requires "x86-configuration.k"
requires "x86-flag-checks.k"
module VPCLMULQDQ-XMM-XMM-XMM-IMM8
  imports X86-CONFIGURATION
  imports X86-FLAG-CHECKS

    /*
    IF (Imm8[0] = 0 )
        THEN
            TEMP1←SRC1 [63:0];
        ELSE
            TEMP1←SRC1 [127:64];
    FI
    IF (Imm8[4] = 0 )
        THEN
            TEMP2←SRC2 [63:0];
        ELSE
            TEMP2←SRC2 [127:64];

       For i = 0 to 63 {
        TmpB [ i ]←(TEMP1[ 0 ] and TEMP2[ i ]);
        For j = 1 to i {
            TmpB [ i ]←TmpB [ i ] xor (TEMP1[ j ] and TEMP2[ i - j ])
        }
        DEST[ i ]←TmpB[ i ];

    For i = 64 to 126 {
    TmpB [ i ]←0;
    For j = i - 63 to 63 {
        TmpB [ i ]←TmpB [ i ] xor (TEMP1[ j ] and TEMP2[ i - j ])
    }
    DEST[ i ]←TmpB[ i ];


  */   
  rule <k>                          //SRC2  //SRC1
    execinstr (vpclmulqdq Imm8:Imm, R2:Xmm, R3:Xmm, R4:Xmm, .Operands) => 
      execinstr(vpclmulqdq 
          // IMM[0] is for SRC1
          selectSlice(getRegisterValue(R3, RSMap), handleImmediateWithSignExtend(Imm8,
              8, 8), 7, 64, 0),
          // IMM[4] is for SRC2
          selectSlice(getRegisterValue(R2, RSMap), handleImmediateWithSignExtend(Imm8,
              8, 8), 3, 64, 0), R4
          , .Operands)
  ...</k>
    <regstate> RSMap </regstate>

  rule <k>
    execinstr (vpclmulqdq TEMP1:MInt, TEMP2:MInt, R4:Xmm,   .Operands) => 
      setParentValue(
          concatenateMInt(
            mi(128, 0), 
            orMInt(
              computePCLMULQDQ1(TEMP1, TEMP2, mi(128, 0), 0, 63), 
              computePCLMULQDQ2(TEMP1, TEMP2, mi(128, 0), 64, 126) 
            )), R4)
  ...</k>
endmodule

module VPCLMULQDQ-XMM-XMM-XMM-IMM8-SEMANTICS
  imports VPCLMULQDQ-XMM-XMM-XMM-IMM8
endmodule
